{-
TorXakis :: Model-Based Testing
Test model for the OS Movement Refactor (branches/feature-movement-refactor)
-}

-- The max ID, IE how many items are being moved at the same time
CONSTDEF maxId :: Int ::= 0 ENDDEF

-- Internal message types:
-- used to synchronize between main model and sub-models.
TYPEDEF  Internal ::=
   Blargh
ENDDEF

-- External message types:
-- these are the messages that the SUT understands via its test adapter.
TYPEDEF  External ::=
 MoveDequeue

 | MoveCreate { moveCreateId :: Int }
 | MovePause { movePauseId :: Int }
 | MoveResume { moveResumeId :: Int }
 | MoveAbort { moveAbortId :: Int }
 | MoveComplete { moveCompleteId :: Int }

 | MoveCreated { moveCreatedId :: Int }
 | MoveStarted { moveStartedId :: Int }
 | MovePaused { movePausedId :: Int }
 | MoveResumed { moveResumedId :: Int }
 | MoveAborted { moveAbortedId :: Int }
 | MoveCompleted { moveCompletedId :: Int }
ENDDEF

-- All channel definitions:
CHANDEF Channels ::=
 Input, Output :: External;
 Sync1 :: Internal;
ENDDEF

-- Type for queue of commands
TYPEDEF Queue ::=
 Null
 | New { head :: External; tail :: Queue }
ENDDEF

-- Adding an input to a queue of commands
FUNCDEF add ( input :: External; queue :: Queue ) :: Queue
 ::=
  IF isNull(queue)
  THEN New(input,Null)
  ELSE New(head(queue),add(input,tail(queue)))
  FI
ENDDEF

-- Model for queue of inputs
STAUTDEF queue [Input :: External; Output :: External] ()
 ::=
  STATE s0, s1

  VAR queue :: Queue

  INIT s0 { queue := Null }

  TRANS s0 -> Input ? input [[ IF isMoveCreate(input) THEN ((moveCreateId(input) >= 0) /\ (moveCreateId(input) <= maxId)) ELSE
                                 IF isMovePause(input) THEN ((movePauseId(input) >= 0) /\ (movePauseId(input) <= maxId)) ELSE
                                 IF isMoveResume(input) THEN ((moveResumeId(input) >= 0) /\ (moveResumeId(input) <= maxId)) ELSE
                                 IF isMoveAbort(input) THEN ((moveAbortId(input) >= 0) /\ (moveAbortId(input) <= maxId)) ELSE
                                 IF isMoveComplete(input) THEN ((moveCompleteId(input) >= 0) /\ (moveCompleteId(input) <= maxId)) ELSE
                                 False FI FI FI FI FI ]]
                              { queue := add(input,queue) } -> s0
        --s0 -> Output ! MoveDequeue [[ isNull(queue) ]] -> s0
        s0 -> Output ! MoveDequeue [[ not(isNull(queue)) ]] -> s1
        s1 -> Output ! head(queue) [[ isNew(queue) ]] { queue := tail(queue) } -> s0

ENDDEF

{-
STAUTDEF Move [Input :: Inputs; Output :: Outputs] (i :: Int)
 ::=
  STATE Idle, Created, Started, Paused, Stopped
  
  VAR id :: Int
  
  INIT Idle { id := i }
  
  TRANS
    Idle -> Input ? create [[ IF isMoveCreate(create) THEN moveCreateId(create) == id ELSE False FI ]] -> Created
    --Created -> Output ? start [[ IF isMoveStart(start) THEN moveStartId(start) == id ELSE False FI ]] -> Started
    --Started -> Input ? pause [[ IF isMovePause(pause) THEN movePauseId(pause) == id ELSE False FI ]] -> Paused
    --Paused -> Input ? resume [[ IF isMoveResume(resume) THEN moveResumeId(resume) == id ELSE False FI ]] -> Started
    --Started -> Input ? abort [[ IF isMoveAbort(abort) THEN moveAbortId(abort) == id ELSE False FI ]] -> Stopped
    --Paused -> Input ? abort [[ IF isMoveAbort(abort) THEN moveAbortId(abort) == id ELSE False FI ]] -> Stopped
    --Started -> Output ? complete [[ IF isMoveComplete(complete) THEN moveCompleteId(complete) == id ELSE False FI ]] -> Stopped
    --Paused -> Output ? complete [[ IF isMoveComplete(complete) THEN moveCompleteId(complete) == id ELSE False FI ]] -> Stopped
    
ENDDEF
-}

-- The test model consists of the composition of parametrized processes,
-- synchronized via communication over the internal SYNC channels.
MODELDEF Model ::=
 CHAN IN Input
 CHAN OUT Output

 BEHAVIOUR
   queue [Input, Output] ()
ENDDEF

-- We connect to the system via a single TCP socket: input+output combined.
-- This preserves message order within the stream, as opposed to using
-- multiple TCP sockets: one for each channel.
-- We explicitly use a single INPUT and single OUTPUT channel to enforce
-- message order, using abstract data types to distinguish message types.
CNECTDEF System ::=
 CLIENTSOCK
  --CHAN OUT Sync1 HOST "localhost" PORT 8001
  --ENCODE Sync1 ? s -> ! toString(s)
  
  --CHAN IN Dequeue HOST "localhost" PORT 8002
  --DECODE Dequeue ! fromString(s) <- ? s
 
  CHAN OUT Input HOST "localhost" PORT 9001
  ENCODE Input ? s -> ! toString(s)

  CHAN IN Output HOST "localhost" PORT 9001
  DECODE Output ! fromString(s) <- ? s
ENDDEF

{-

-- The test model consists of the composition of parametrized processes,
-- synchronized via communication over the internal SYNC channels.
MODELDEF Model ::=
 CHAN IN Input
 CHAN OUT Output

 BEHAVIOUR
   Move [Input, Output] ()
ENDDEF

-- We connect to the system via a single TCP socket: input+output combined.
-- This preserves message order within the stream, as opposed to using
-- multiple TCP sockets: one for each channel.
-- We explicitly use a single INPUT and single OUTPUT channel to enforce
-- message order, using abstract data types to distinguish message types.
CNECTDEF System ::=
 CLIENTSOCK
  --CHAN OUT Sync HOST "localhost" PORT 8001
  --ENCODE Sync ? s -> 
  
  CHAN OUT Input HOST "localhost" PORT 9001
  ENCODE Input ? s -> ! toString(s)

  CHAN IN Output HOST "localhost" PORT 9001
  DECODE Output ! fromString(s) <- ? s
ENDDEF

-}
