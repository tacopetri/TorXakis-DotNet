{-
TorXakis :: Model-Based Testing
Test model for the OS Movement Refactor (branches/feature-movement-refactor)
-}

-- The max ID, IE how many items are being moved at the same time
CONSTDEF maxId :: Int ::= 0 ENDDEF

-- Input message types:
TYPEDEF  Inputs ::=
 MoveCreate { moveCreateId :: Int }
 | MovePause { movePauseId :: Int }
 | MoveResume { moveResumeId :: Int }
 | MoveAbort { moveAbortId :: Int }
 | MoveComplete { moveCompleteId :: Int }
ENDDEF

-- Output message types:
TYPEDEF  Outputs ::=
 MoveCreated { moveCreatedId :: Int }
 | MoveStarted { moveStartedId :: Int }
 | MovePaused { movePausedId :: Int }
 | MoveResumed { moveResumedId :: Int }
 | MoveAborted { moveAbortedId :: Int }
 | MoveCompleted { moveCompletedId :: Int }
ENDDEF

-- All channel definitions:
CHANDEF Channels ::=
 Enqueue :: Inputs;
 Dequeue;
 
 Input :: Inputs;
 Output :: Outputs;
ENDDEF

-- Type for queue of inputs
TYPEDEF Queue ::=
 Null
 | New { head :: Inputs; tail :: Queue }
ENDDEF

-- Adding an input to a queue of inputs
FUNCDEF add ( input :: Inputs; queue :: Queue ) :: Queue
 ::=
  IF isNull(queue)
  THEN New(input,Null)
  ELSE New(head(queue),add(input,tail(queue)))
  FI
ENDDEF
 
-- Model for queue of inputs
STAUTDEF  queue  [ Enqueue, Input :: Inputs; Dequeue ]  ( )
 ::=
  STATE s0, s1

  VAR queue :: Queue

  INIT s0 { queue := Null }

  TRANS s0 -> Enqueue ? input [[ IF isMoveCreate(input) THEN ((moveCreateId(input) >= 0) /\ (moveCreateId(input) <= maxId)) ELSE
                                 IF isMovePause(input) THEN ((movePauseId(input) >= 0) /\ (movePauseId(input) <= maxId)) ELSE
                                 IF isMoveResume(input) THEN ((moveResumeId(input) >= 0) /\ (moveResumeId(input) <= maxId)) ELSE
                                 IF isMoveAbort(input) THEN ((moveAbortId(input) >= 0) /\ (moveAbortId(input) <= maxId)) ELSE
                                 IF isMoveComplete(input) THEN ((moveCompleteId(input) >= 0) /\ (moveCompleteId(input) <= maxId)) ELSE
                                 False FI FI FI FI FI ]]
                              { queue := add(input,queue) } -> s0
        s0 -> Dequeue [[ isNull(queue) ]] -> s0
        s0 -> Dequeue [[ not(isNull(queue)) ]] -> s1
        s1 -> Input ! head(queue) [[ not(isNull(queue)) ]] { queue := tail(queue) } -> s0

ENDDEF

-- The test model consists of the composition of parametrized processes,
-- synchronized via communication over the internal SYNC channels.
MODELDEF Model ::=
 CHAN IN Enqueue, Input, Dequeue
 CHAN OUT Output

 BEHAVIOUR
   queue [ Enqueue, Input, Dequeue ] ()
ENDDEF

-- We connect to the system via a single TCP socket: input+output combined.
-- This preserves message order within the stream, as opposed to using
-- multiple TCP sockets: one for each channel.
-- We explicitly use a single INPUT and single OUTPUT channel to enforce
-- message order, using abstract data types to distinguish message types.
CNECTDEF System ::=
 CLIENTSOCK
  CHAN OUT Enqueue HOST "localhost" PORT 8001
  ENCODE Enqueue ? s -> ! toString(s)
  
  CHAN OUT Dequeue HOST "localhost" PORT 8002
  ENCODE Dequeue -> ! "Dequeue"
 
  CHAN OUT Input HOST "localhost" PORT 9001
  ENCODE Input ? s -> ! toString(s)

  CHAN IN Output HOST "localhost" PORT 9001
  DECODE Output ! fromString(s) <- ? s
ENDDEF

{-

STAUTDEF Move [Input :: Inputs; Output :: Outputs]
 ::=
  STATE None, Created, Started, Paused, Stopped
  
  --VAR id :: Int
  
  INIT None --{ id := i }
  
  TRANS
    None -> Input ? MoveCreate -> Created
    Created -> Output ? MoveStarted -> Started
    Started -> Input ? MovePause -> Paused
    Paused -> Input ? MoveResume -> Started
    Started -> Input ? MoveAbort -> Stopped
    Paused -> Input ? MoveAbort -> Stopped
    Started -> Output ? MoveCompleted -> Stopped
    Paused -> Output ? MoveCompleted -> Stopped
    
ENDDEF

-- The test model consists of the composition of parametrized processes,
-- synchronized via communication over the internal SYNC channels.
MODELDEF Model ::=
 CHAN IN Input
 CHAN OUT Output

 BEHAVIOUR
   Move [Input, Output] ()
ENDDEF

-- We connect to the system via a single TCP socket: input+output combined.
-- This preserves message order within the stream, as opposed to using
-- multiple TCP sockets: one for each channel.
-- We explicitly use a single INPUT and single OUTPUT channel to enforce
-- message order, using abstract data types to distinguish message types.
CNECTDEF System ::=
 CLIENTSOCK
  --CHAN OUT Sync HOST "localhost" PORT 8001
  --ENCODE Sync ? s -> 
  
  CHAN OUT Input HOST "localhost" PORT 9001
  ENCODE Input ? s -> ! toString(s)

  CHAN IN Output HOST "localhost" PORT 9001
  DECODE Output ! fromString(s) <- ? s
ENDDEF

-}
