{-
TorXakis :: Model-Based Testing
Test model for the OS Movement Refactor (branches/feature-movement-refactor)
-}

-- The max ID, IE how many items are being moved at the same time
CONSTDEF maxId :: Int ::= 0 ENDDEF

-- External message types:
-- these are the messages that the SUT understands via its test adapter.
TYPEDEF  External ::=
 MoveDequeue

 | MoveCreate { moveCreateId :: Int }
 | MovePause { movePauseId :: Int }
 | MoveResume { moveResumeId :: Int }
 | MoveAbort { moveAbortId :: Int }
 | MoveComplete { moveCompleteId :: Int }

 | MoveCreated { moveCreatedId :: Int }
 | MoveStarted { moveStartedId :: Int }
 | MovePaused { movePausedId :: Int }
 | MoveResumed { moveResumedId :: Int }
 | MoveAborted { moveAbortedId :: Int }
 | MoveCompleted { moveCompletedId :: Int }
ENDDEF

-- All channel definitions:
CHANDEF Channels ::=
 Input :: External;
 Output :: External;
 Sync :: External;
ENDDEF

-- Type for queue of commands
TYPEDEF Queue ::=
 Null
 | New { head :: External; tail :: Queue }
ENDDEF

-- Add method for queue of commands
FUNCDEF add ( input :: External; queue :: Queue ) :: Queue
 ::=
  IF isNull(queue)
  THEN New(input,Null)
  ELSE New(head(queue),add(input,tail(queue)))
  FI
ENDDEF

-- Model for queue of commands
STAUTDEF CommandQueue [Input :: External; Sync :: External] ()
 ::=
  STATE s0, s1

  VAR queue :: Queue

  INIT s0 { queue := Null }

  TRANS s0 -> Input ? input [[ IF isMoveCreate(input) THEN ((moveCreateId(input) >= 0) /\ (moveCreateId(input) <= maxId)) ELSE
                                 IF isMovePause(input) THEN ((movePauseId(input) >= 0) /\ (movePauseId(input) <= maxId)) ELSE
                                 IF isMoveResume(input) THEN ((moveResumeId(input) >= 0) /\ (moveResumeId(input) <= maxId)) ELSE
                                 IF isMoveAbort(input) THEN ((moveAbortId(input) >= 0) /\ (moveAbortId(input) <= maxId)) ELSE
                                 IF isMoveComplete(input) THEN ((moveCompleteId(input) >= 0) /\ (moveCompleteId(input) <= maxId)) ELSE
                                 False FI FI FI FI FI ]]
                              { queue := add(input,queue) } -> s0
        s0 -> Sync ! MoveDequeue [[ isNew(queue) ]] -> s1
        s1 -> Sync ! head(queue) [[ isNew(queue) ]] { queue := tail(queue) } -> s0

ENDDEF

STAUTDEF Move [Sync :: External; Output :: External] (i :: Int)
 ::=
  STATE Idle, Created, Started, Paused, Create, Pause, Resume, Abort, Complete
  
  VAR id :: Int
  
  INIT Idle { id := i }
  
  TRANS
    Idle -> Sync ! MoveDequeue -> Idle
    Created -> Sync ! MoveDequeue -> Created
    Started -> Sync ! MoveDequeue -> Started
    Paused -> Sync ! MoveDequeue -> Paused
  
    Idle -> Sync ! MoveCreate(id) -> Create
    Idle -> Sync ! MovePause(id) -> Idle
    Idle -> Sync ! MoveResume(id) -> Idle
    Idle -> Sync ! MoveAbort(id) -> Idle
    Idle -> Sync ! MoveComplete(id) -> Idle

    Created -> Output ! MoveStarted(id) -> Started

    Started -> Output ! MoveCreate(id) -> Started
    Started -> Output ! MovePause(id) -> Pause
    Started -> Output ! MoveResume(id) -> Started
    Started -> Output ! MoveAbort(id) -> Abort
    Started -> Output ! MoveComplete(id) -> Complete

    Paused -> Output ! MoveCreate(id) -> Paused
    Paused -> Output ! MovePause(id) -> Paused
    Paused -> Output ! MoveResume(id) -> Resume
    Paused -> Output ! MoveAbort(id) -> Abort
    Paused -> Output ! MoveComplete(id) -> Complete
    
    Create -> Output ! MoveCreated(id) -> Created
    Pause -> Output ! MovePaused(id) -> Paused
    Resume -> Output ! MoveResumed(id) -> Started
    Abort -> Output ! MoveAborted(id) -> Idle
    Complete -> Output ! MoveCompleted(id) -> Idle

ENDDEF

-- The test model consists of the composition of parametrized processes,
-- synchronized via communication over the internal SYNC channels.
MODELDEF Model ::=
 CHAN IN Input
 CHAN OUT Sync, Output

 BEHAVIOUR
   CommandQueue [Input, Sync] ()
   |[Sync]|
   (
    Move [Sync, Output] (0) --|||
    --Move [Sync, Output] (1) |||
    --Move [Sync, Output] (2)
   )
ENDDEF

-- We connect to the system via a single TCP socket: input+output combined.
-- This preserves message order within the stream, as opposed to using
-- multiple TCP sockets: one for each channel.
-- We explicitly use a single INPUT and single OUTPUT channel to enforce
-- message order, using abstract data types to distinguish message types.
CNECTDEF System ::=
 CLIENTSOCK
  CHAN OUT Sync HOST "localhost" PORT 8001
  ENCODE Sync ? s -> ! toString(s)

  CHAN OUT Input HOST "localhost" PORT 9001
  ENCODE Input ? s -> ! toString(s)

  CHAN IN Output HOST "localhost" PORT 9001
  DECODE Output ! fromString(s) <- ? s
ENDDEF
